{"meta":{"title":"前端旅途","subtitle":"在读大学生一枚","description":"希望自己成为那个想成为的人吧","author":"LaoJI","url":"http://jmu.name"},"posts":[{"title":"http协议","slug":"http协议","date":"2018-06-14T02:49:01.000Z","updated":"2018-06-14T03:21:27.490Z","comments":true,"path":"2018/06/14/http协议/","link":"","permalink":"http://jmu.name/2018/06/14/http协议/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"协议","slug":"协议","permalink":"http://jmu.name/categories/协议/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://jmu.name/tags/Http/"},{"name":"面试","slug":"面试","permalink":"http://jmu.name/tags/面试/"}]},{"title":"python编码","slug":"python编码","date":"2017-05-29T01:09:44.000Z","updated":"2017-05-29T01:44:29.788Z","comments":true,"path":"2017/05/29/python编码/","link":"","permalink":"http://jmu.name/2017/05/29/python编码/","excerpt":"","text":"计算机只能处理数字，文本转换为数字才能处理。计算机中8个bit作为一个字节，所以一个字节能表示最大的数字就是255 计算机是美国人发明的，所以一个字节可以表示所有字符了，所以ASCII(一个字节)编码就成为美国人的标准编码 但是ASCII处理中文明显是不够的，中文不止255个汉字，所以中国制定了GB2312编码，用两个字节表示一个汉字。如果遇到生僻的汉字可以采用3个及3个以上编码。GB2312还把ASCII包含进去了。同理，日文，韩文等上百个国家都发展了一套自己语言的字节的编码。标准越来越多，所以如果在一篇文章中出现多种语言混合显示就一定会出现乱码。 于是unicode（16bit or 32 or 64）出现了，将所有语言统一到一套编码里 看一下ASCII和unicode编码： 字母A用ASCII编码十进制是65，二进制为0100 0001 汉字”中”以及超出了ASCII编码的范围，用unicode编码20013 二进制是01001110 00101101 A用unicode编码只需要前面补0 二进制是00000000 0100 0001 6.乱码问题解决了，但是如果内容全是英文，unicode编码比ASCII需要多一倍的存储空间，同时如果传输 那就需要多一倍的传输。 7.所以出现了可变长的编码 “utf-8”.它把英文变为一个字节编码，汉字3个字节，特别生僻的变成4-6字节,如果传输大量的英文，utf-8作用就很明显了 python3中已经把所有字符串默认成unicode编码了 python2需要分析下 在windows系统中，字符串默认是GB2312的，linux中默认是utf-8而python2中想像下图中使用encode(“utf8”)编码，必须先编码成unicode才行所以，可以采用 先解码 在编码即s.decode(“gb2312”).encode(“utf-8”) 在linux中即s.decode(“utf-8”).encode(“utf-8”) 原理分析因为我们在.encode的时候，它首先会默认用系统自带encoding去decode而linux里的是下面ASCII编码。所以必当报错 python2在文件头加上# -- coding: -- 就可以识别文件中的中文了","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-03-27T03:10:17.436Z","updated":"2017-03-09T12:16:16.000Z","comments":true,"path":"2017/03/27/hello-world/","link":"","permalink":"http://jmu.name/2017/03/27/hello-world/","excerpt":"","text":"从头开始。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"CSS3day2","slug":"CSS3day2","date":"2017-03-16T10:25:16.000Z","updated":"2017-03-16T10:38:22.304Z","comments":true,"path":"2017/03/16/CSS3day2/","link":"","permalink":"http://jmu.name/2017/03/16/CSS3day2/","excerpt":"","text":"1、边框边框圆角： border-radius:30px; border-radius:30px 40px 50px 60px; 赋值规律： 从左上开始，顺时针赋值，如果这个角没有值 ，去对角； border-radius: 40px/60px; 边框阴影： box-shadow: 水平位移 垂直位移 模糊程度 阴影大小 阴影颜色 外/内阴影(inset) 边框图片： border-image-source: 图片路径 border-image-slice: 裁剪 border-image-width: 边框宽度 border-image-repeat: 边框图片的平铺 repeat: 图片显示不完整 round: 图片平铺 优化了，图片会完整显示 stretch: 拉伸 2、背景： 背景可以改变大小，可以有多个背景 background-size: 30px 30px; background-size: 30% 30%; background-size: cover; 覆盖 background-size: contain; 包含 可以有多个背景: 多个背景按照正常的语法格式书写，每个背景使用逗号隔开 背景原点： background-origin: content-box padding-box border-box 背景裁剪 background-clip: content-box padding-box border-box 3、渐变 线性渐变： background-image: linear-gradient(方向，起始颜色，终止颜色); 方向：to left right bottom top 35deg 径向渐变： radial-gradient（辐射半径 中心点位置，起始颜色，终 止颜色） 中心点颜色，at left，right，top，bottom，center at 50px（水平距离） 50px（垂直距离） 4、过渡 /* 过渡属性* /*transition:width 2s,background-color 2s;*/ /* 如果多个过度的 特性是一样的 可以简写*/ /* transition: 过渡属性 持续时间 运动曲线 延迟时间*/ transition:all 4s linear 1s ; /* 过渡必须加给盒子本身*/ /* 过渡的属性详解*/ transition：过渡属性 过渡时间 速度曲线（linear：匀速） 延迟时间 transition-property：过渡属性 transition-duration：过渡持续时间 transition-timimg-function：运动曲线 linear：匀速 ease：减速 ease-in：加速 ease-out：减速 ease-in-out：先加速后减速 transition-delay：过渡延迟 如果需要所有属性都过渡 transition-property：all； 5、2D变换 transform 缩放、旋转、移动 变换后不会影响其他盒子 缩放scale（倍率） 不可以写百分数 大于1是放大，小于一缩小 写一个值，宽高等比缩放 内容也会等比缩放 写两个值，第一个是水平缩放倍率，第二个是垂直缩放倍率 位移translate（） 右移正数，左移负数（右下为正，左下为负） 第一个值水平移动，第二个值垂直移动距离 可写百分比数值，相对与自身的尺寸 盒子在父盒子中居中方法 position：absolute； left：50%； transform：translate（-50%）； 旋转：rotate（角度） 正值顺时针，负值逆时针 旋转中心：transform-origin：水平坐标 垂直坐标 默认旋转中心：几何中心 学习案列","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之基础(一）","slug":"js之基础-一）","date":"2017-03-13T11:37:47.000Z","updated":"2017-03-13T11:52:47.663Z","comments":true,"path":"2017/03/13/js之基础-一）/","link":"","permalink":"http://jmu.name/2017/03/13/js之基础-一）/","excerpt":"","text":"先复习点基础的css和html知识。1、如何的给我们的HTML结构增加CSS样式 1)行内样式 -&gt;直接的在HTML标签上增加style=’….样式都写在这里 src12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 应用于单独的给某一个元素增加样式(一般在写css样式的时候我们都 不用) 2)**内嵌样式** -&gt;在HEAD中增加style标签,然后把需要给元素设置的样式都写在style里面 3)**外联样式** -&gt;为了让HTML页面中的标签和我们的样式分离开，我们把样式写在一个外部的文件中，然后在通过link引入进来 `&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/test1.css&quot;/&gt;` 4)**导入式** -&gt;和外链式相同，都是把样式文件写在外面，然后通过@import导入进来 `@import &quot;css/test2.css&quot;;`# JS中常用的几种输出方式 ### 1、alert(&quot;我们要输出的内容&quot;) ## -&gt;在浏览器中弹出一个对话框,然后把要输出的内容展示出来 -&gt;alert都是把要输出的内容首先转换为字符串然后在输出的 ## 2、document.write(&quot;我们要输出的内容&quot;) ## -&gt;直接的在页面中展示我们输出的内容 ## 3、console.log(我们要输出的内容) ## -&gt;在控制台输出我们的内容 -&gt;如何打开/查看控制台 -&gt;所有的浏览器都是F12这个键打开，拿谷歌浏览器来说，控制台包含了很多项： Elements:展示的是我们页面中的HTML结构,但是它最主要的功能就是 随时的调试我们的css样式(等价于火狐浏览器中的fire bug) Console:我们在控制台输出的内容都可以在这里查看,不仅如此,我该 可以在这里编写js代码 Sources:我们网站中的CSS/JS/HTML所有页面的文件都在这里可以下 载查看,可以通过这个扒别人的源码 Network:展示了页面所有的加载资源(CSS/JS/img/Ajax/ JSONP...)，并且每一个资源文件加载的时间都能看到, 通过这个我们可以进行页面的性能优化 ...... -&gt;console.dir(我们要输出的内容) 这种方式比.log输出的内容更加的详细 -&gt;console.table&gt; [这里对console.table讲的很清楚](http://www.cnblogs.com/justany/p/3429097.html &quot;去看看吧&quot;)## 4、value ## -&gt;给文本框(表单元素)赋值内容 -&gt;获取文本框中(表单元素)的内容 document.getElementById(&quot;search&quot;).value = &quot;我们要给#search这个文本框添加的内容&quot;;## 5、innerHTML/innerText ## -&gt;给除了表单元素的标签赋值内容 document.getElementById(&quot;div1&quot;).innerHTML = &quot;勿忘初心方 得始终~~&quot;; document.getElementById(&quot;div1&quot;).innerText = &quot;在没有努力 之前不要谈天赋和基础~~&quot;;### innerHTML和innerText的区别 ## 1)innerHTML在赋值的时候,如果遇到了有效的HTML标签会把它当做真 正的标签处理,标签就可以起到自己的作用了；innerText不管是不是 标签都当做文本来赋值，那么看到的都是文本，标签起不到自己的作 用；(总结：在赋值的时候innerHTML可以识别HTML标签，而 innerText不能识别) document.getElementById(&quot;div1&quot;).innerHTML = &quot;&lt;a href=&apos;http://www.zhufengpeixun.cn/&apos;&gt;珠峰培训的官网&lt;/a&gt;&quot;; document.getElementById(&quot;div1&quot;).innerText = &quot;&lt;a href=&apos;http://www.zhufengpeixun.cn/&apos;&gt;珠峰培训的官网&lt;/a&gt;&quot;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 2)在部分火狐浏览器中，不支持innerText,而innerHTML是所有浏览 器都支持的 思考题：script上除了type属性还有哪些常用的属性? defer asyncJS:JavaScript的一个缩写,它是一门轻量级的脚本&quot;编程语言&quot;,它是由三部分组成的: ECMAScript:定义了JS的基本语法、命名规范、变量、数据类型、操作语句...最为基础也是最为核心的知识DOM: document object model 文档对象模型 -&gt;提供了JS操作页面中元素的常用方法和属性(例如:getElementById就是DOM提供的一个获取元素的方法)BOM: browser object model 浏览器对象模型 -&gt;提供了JS操作浏览器的一些相关的属性和方法(例如:我们可以监听浏览器的关闭事件,在关闭的时候做一些自己的事情)```javascript var num = 12; var str = &quot;LaoJI&quot;; var boo = true;//false var n = null; var u = undefined; var obj = &#123;name: &quot;LaoJI&quot;, age: 25&#125;;//对象 var ary = [12, 23, 34, 45];//数组 var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/;//正则 var fn = function () &#123; &#125;; 1、JS中的数据类型一共分为两大类 [基本数据类型/值类型] number、string、boolean、null、undefined [引用数据类型] object对象数据类型[&#123;&#125;对象、[]数组、/^$/正则...] function函数数据类型 2、用JS检测它到底是说什么数据类型的 1)typeof 用来检测数据类型的逻辑运算符 typeof value; -&gt;检测value这个值的数据类型 console.log(typeof 12);//-&gt;&quot;number&quot; 在控制台看到的是没有加&quot;&quot;，这是浏览器的一个机制,在JS中输出,在控制台默认的把&quot;&quot;给省略了 返回值:首先是一个字符串,其次里面才包含了我们对应的数据类型,例如:&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot;、&quot;undefined&quot;... 注意: console.log(typeof null);//-&gt;&quot;object&quot; typeof不能具体的细分object下的数组、正则、对象，因为不管检测哪一个返回的都是&quot;object&quot;,例如：typeof [12] -&gt;&quot;object&quot; typeof /^$/ -&gt;&quot;object&quot; BAT面试题 console.log(typeof typeof typeof typeof [12, 23, 34]);//-&gt;&quot;string&quot; typeof检测的返回值不管是啥，首先都是一个字符串，如果出现两个及以上同时检测的话，最后结果一秒钟出答案-&gt;&quot;string&quot; typeof [12, 23, 34] -&gt; &quot;object&quot; typeof &quot;object&quot; -&gt; &quot;string&quot; typeof &quot;string&quot; -&gt; &quot;string&quot; typeof &quot;string&quot; -&gt; &quot;string&quot; 2)instanceof 判断某一个实例是否属于这个类 3)constructor 通过实例的构造函数的执行检测数据类型 4)Object.prototype.toString.call() 调用Object基类原型上的toString方法，让里面的this变为我们要检测值，由此返回对应的数据类型 自然界中的有效数字：正数、负数、零、小数 1、JS中也有一个非常变态的也是数字:NaN NaN:not a number 不是一个数 1)但是它是number类型的 typeof NaN -&gt;&quot;number&quot; 2)由于NaN包含的内容太广泛了,所以NaN和NaN是不相等的 NaN==NaN -&gt;false 2、将其他数据类型的值转化为number类型 1)Number(value) 严格强制的把value转化为number类型值 Number(&quot;100&quot;) -&gt; 100 Number(&quot;100px&quot;) -&gt; NaN 严格:对于一个字符串来说,只有所有的字符都是有效的数字才能转化为数字，只要有一个字符不是，结果就是NaN Number(&quot;&quot;) -&gt; 0 2)parseInt/parseFloat 非严格转换，把其他数据值转换为数字类型的 parseInt(&quot;100px&quot;) -&gt; 100 从左到右查找有效的数字字符,然后把找到的转换为数字，一但遇到一个非有效数字的字符，则停止查找(不管后面是否还有数字都不在找了) parseInt(&quot;100px200&quot;) -&gt; 100 parseInt(&quot;px100&quot;) -&gt; NaN 如果一个都没有找到的话，结果就是NaN parseInt(&quot;100.5px&quot;) -&gt; 100 parseFloat(&quot;100.5px&quot;) -&gt; 100.5 parseFloat比parseInt多识别一个小数点 3、我可以通过判断 &quot;wee&quot;==NaN 如果相等,就说明&quot;wee&quot;不是一个有效数字吗? -&gt;不能，因为NaN和自己都不相等，它和任何一个值都不是相等的 在JS中提供了一个检测是否为有效数字的方法-&gt;isNaN(value) 检测value是否为一个有效的数字，如果是有效的数字返回false，如果不是有效数字才返回true isNaN(12) -&gt;false 说明12是一个有效的数字 isNaN(&quot;12&quot;) -&gt;false 说明“12”是一个有效的数字，当检测的时候，检测的值不是一个number类型的，我们首先转换为number类型，然后在进行判断 4、保留小数点后面的位数 -&gt; toFixed console.log(3.141592654.toFixed(2));//-&gt;&quot;3.14&quot; =:赋值 右边是值,左边是我们的变量,把值赋值给变量 var num = 12;//把12赋值给变量num num=12 var num2 = num;//把num这个变量存储(代表)的值赋值给变量num2 num2=12 ==:比较 判断左边和右边是否相等,相等的话返回的结果是true,不相等返回的结果是false 12==12 -&gt; true &quot;12&quot;==12 -&gt; true 在==进行比较的时候，首先会判断左右两边的数据类型是否一致，如果数据类型相同则继续比较值；如果左右两边的数据类型不一样，浏览器会默认的把它们转换成一样的数据类型才比较；例如： &quot;12&quot;==12 左边是个字符串，右边是一个数字，浏览器首先会把左边的字符串转换为数字12,然后在和右边比较 浏览器是如和的把字符串转化为数字的? -&gt; Number(&quot;12&quot;) 除了字符串和数字以外，其他的数据类型在进行比较的时候，是如何的转换的呢? -&gt;免费课教材最后一页 7.2附表 ===:绝对比较 如果遇到两边的数据类型不一行的话，返回的结果就是不相等，不会像==一样进行数据类型的转换 BAT实战面试题: var num = parseInt(&quot;px100&quot;);//-&gt;num=NaN if (num == 100) { console.log(100); } else if (num == NaN) { console.log(NaN); } else if (typeof num === &quot;number&quot;) {//typeof NaN -&gt;&quot;number&quot; console.log(&quot;number&quot;); } else { console.log(&quot;啥也不是&quot;); } //-&gt;&quot;number&quot;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"HTML5(一)","slug":"HTML5-一","date":"2017-03-13T10:53:43.000Z","updated":"2017-03-13T11:32:40.641Z","comments":true,"path":"2017/03/13/HTML5-一/","link":"","permalink":"http://jmu.name/2017/03/13/HTML5-一/","excerpt":"","text":"1、HTML5:HTML4.1 网页开发： 结构: html4.0 样式：css css2 行为：js HTML5: 是HTML4的升级版本(狭义) 结构：html5 样式：css3 行为：js API 有所增强 地理定位 web存储 拖拽 HTML5广义的概念: 代表着浏览器技术发展的一阶段，HTML5+CSS3+js API 一套前端技术的组合； 案列 2、新增语义化标签header 头部 nav 导航 section 区域 aside 侧边栏 article 文章 footer 底部 progress 进度条 案列 3、表单 表单类型： type=”text” email tel url search number step:步长 color range value max min time date month week 有兼容性问题 案列 表单元素： ``` &lt;input type=&quot;search&quot; list=&quot;sex&quot;/&gt; 数据列表 &lt;datalist id=&quot;sex&quot;&gt; &lt;option&gt;男&lt;/option&gt; &lt;option&gt;男&lt;/option&gt; &lt;option&gt;男&lt;/option&gt; &lt;/datalist&gt; &lt;output&gt;&lt;/output&gt; 输出信息 &lt;keygen/&gt; 生成密钥的 用于表单安全传输 &lt;meter&gt;&lt;/meter&gt; 度量器 max min value low high &lt;progress&gt;&lt;/progress&gt; 进度条 max min value 表单属性： placeholder:提示文字 autofocus:自动聚焦 autocomplete：自动完成（填充） on 开启（默认） off 取消提示 required:必填 multiple: 多选 novalidate: 关闭表单的默认验证功能 用于form pattern: 自定义正则验证 pattern=&quot;\\D+&quot;; 表单事件： oninput:当用户输入时 触发 oninvalid:当验证不通过是触发--&gt;设置验证不通过时的提示文字 ` 案列 4、多媒体之前： 在网页上播放 多媒体 必须依赖于第三方 插件 mediaplay: 快播： falsh插件： H5里面提供了 视频 和 音频的标签 audio video 案列 5、DOM拓展document 对象 文档对象 当在浏览器中 打开一个页面后， 浏览器首先会来解析我们的 网页，把解析出来的数据，存放到一个DOM对象中； document.getElmentById(); 在H5中 DOM新增的功能： jquery--- $(&apos;.box&apos;); $(&apos;#box&apos;); $(&apos;div.box); $(&apos;div p&apos;); 案列 获取单个元素：document.querySelector(&apos;.box‘); 获取所有符合条件的元素： 返回的数组 document.querySeletorAll(&apos;.box&apos;); 控制类名的API： node.classList.add();添加类名 node.classList.remove()；删除类名 node.classlist.contains();判断是否包含指定的类名 node.classList.toggle()；切换指定的类名 案列 综合案列tab标签 Tab栏练习","raw":null,"content":null,"categories":[],"tags":[]},{"title":"CSS3之选择器","slug":"CSS3之选择器","date":"2017-03-12T10:10:54.000Z","updated":"2017-03-12T12:37:15.301Z","comments":true,"path":"2017/03/12/CSS3之选择器/","link":"","permalink":"http://jmu.name/2017/03/12/CSS3之选择器/","excerpt":"","text":"CSS3刚接触。我尽量把我学习过程分享给大家。大家有啥问题评论下哈。 div&gt;p: 子代 div+p： div后面相邻的第一个p div~p: div后面所有的兄弟p 案列 1、属性选择器：id选择器 # 通过id 来选择 类名选择器 . 通过类名来选择 属性选择器 [] 通过标签属性来选择器 语法： 标志性符号：[] ^: 开头 $:结尾 *：包含 E[title] : 选中页面的E元素，并且E需要带有title属性 E[title=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值为abc E[title^=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值以abc开头 E[title$=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值以abc结尾 E[title*=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值包含abc 案列 结构伪类选择器： E：first-child 选中父元素中的第一个子元素 E：last-child 选中父元素中的最后一个子元素 E：nth-child(1) 选中父元素中的第5个子元素 n: 0,1,2,3,4。。。 偶数： 2n even 奇数：2n-1 odd 前5个： -n+5 E：nth-last-child(3): 从后向前选择， 选中倒数第3个 div:nth-child(9) 注意：所选到的元素的类型 必须是指定的类型E,否则选择无效； E：empty 表示元素为空的状态 E:target: 表示元素被激活的状态 要配合锚点使用 案列 伪元素：通过css模拟出html效果 E::before E::after 必须有content 属性 案列 伪元素选择器：E::first-letter 选中第一个字母 E::first-line选中第一行 E::selection: 表示选择的区域 通过设置 color background 案列 CSS3中新增了两种颜色模式 ：RGBA: red green blue (0-255) alpha: 透明度 （0-1） HSLA: H:色调 0-360 0 红色 120 绿色 240 蓝色 S:饱和度 0%-100% L:亮度 0%-100% A：alpha 透明度 0-1 text-shadow:水平位移 垂直位移 模糊度 颜色 盒子模型： 三个盒子： content-box padding-box border-box box-sizing: border-box(内减模式)border-box(内减模式) /content-box（外加模式）(默认值) box-sizing: border-box 盒模型 私有化前缀： 浏览器私有化前缀： -webkit-: 谷歌 苹果 -moz-:火狐 -ms-：ie -o-：欧朋","raw":null,"content":null,"categories":[],"tags":[]},{"title":"A pageDemo","slug":"A-pageDemo","date":"2017-03-11T02:19:36.000Z","updated":"2017-03-11T02:22:00.569Z","comments":true,"path":"2017/03/11/A-pageDemo/","link":"","permalink":"http://jmu.name/2017/03/11/A-pageDemo/","excerpt":"","text":"#学完css后做的一个小小的主页demo(浏览者莫喷啦)#下面图解主页面的盒子模型 头部 导航 信息 新闻 底部 源码请左转-&gt; https://github.com/HeyGary/pagedemo/","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hexo站点之域名配置(GitHub)","slug":"Hexo站点之域名配置-GitHub","date":"2017-03-10T13:25:10.000Z","updated":"2017-03-10T13:39:12.089Z","comments":true,"path":"2017/03/10/Hexo站点之域名配置-GitHub/","link":"","permalink":"http://jmu.name/2017/03/10/Hexo站点之域名配置-GitHub/","excerpt":"","text":"起因 因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。 步骤 购买域名 腾讯云、阿里云都是不错的选择。博主选用的是腾讯云的 建议如果只是作为自己的博客使用建议不要购买.com的域名（辣么贵） 域名解析 这里没图我说个** 先登录腾讯云 点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是heygary.github.io 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：jmu.name。实践证明如果此时你填写的是www.jmu.name那么以后你只能用www.jmu.name访问，而如果你填写的是jmu.name。那么用www.jmu.name和jmu.name访问都是可以的。重新清理hexo(hexo clean命令),并发布即可用新的域名访问。 搭建完成访问出现404 可能的原因是：绑定了个人域名，但是域名解析错误。域名解析正确但你的域名是通过国内注册商注册的，你的域名因没有实名制而无法访问。你认为配置没有问题，那么可能只是你的浏览器在捣鬼，可尝试清除浏览器缓存再访问或者换个浏览器访问。也有可能是你的路由器缓存导致的错觉，所以也可以尝试换个局域网访问你的网站。最有可能的原因是你下载的hexo有问题，导致所有的东西都上传到了github,而导致index页面在主域名的下一级目录。你可以尝试查看上传的内容，找到index页面，在域名后面添加下一级目录。若能访问index页面（此时样式可能是乱的），则证明是hexo安装有问题，笔者当时遇到的就是这个问题。可卸载重新安装。注：1，2默认你的CNAME文件配置没有问题，如果没有绑定个人域名，则不需要CNAME文件。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Git操作","slug":"Git操作","date":"2017-03-10T04:21:43.000Z","updated":"2017-03-13T11:25:23.658Z","comments":true,"path":"2017/03/10/Git操作/","link":"","permalink":"http://jmu.name/2017/03/10/Git操作/","excerpt":"","text":"使用中遇到的问题最近更新了Git版本，发现在github上建立了一个仓库，然后关联本地库的时候pull失败，错误为fatal: refusing to merge unrelated histories，查找后找到了解决方案 将之前的git pull origin master修改为一下代码git pull origin master –allow-unrelated-histories 1.常用命令：1)win+R:打开命令行2)git –version:查看git的版本，知道git安装是否成功；3）清除命令行：cls(window系统) clear(linux,mac);4)ls -a:查看当前文件夹下所有的文件（隐藏+显示的文件夹）5）添加远程通道：git remote add XXXX;删除远程通道 git remote rm 通道名 2.git配置：git config –global user.name “你的github用户名”git config –global user.email “你的github邮箱” 3.创建一个git本地仓库：1、新建一个文件夹 2、进入这个文件夹，右键git bash or 左手shift+右键“在此处打开命令窗口” 3、git init :把本地仓库初始化为一个git可以管理的仓库； 4.建立远程仓库：1.右上角“+” 2.输入仓库名称- create 5.把“本地仓库”所有内容，推送到“远程仓库” #：1）git add . git add -A git add --all 2) git commit -m&quot;注释内容&quot; 3) git push origin master 6.学员更新老师讲义（开发人员更新项目）1）登录自己的github，然后把老师讲义地址，复制到地址栏 https://github.com/zhufengpeixun/Javascript201614.git 2）把自己的远程仓库，下载到本地； git clone https://github.com/leilei1238/Javascript201614.git 3)连接老师远程通道： git remote add teacher https://github.com/zhufengpeixun/Javascript201614.git 查看链接了哪些通道：git remote -v 删除远程通道：git remote rm 通道名称 4)更新老师远程通道 git remote update teacher git pull teacher master .......................................","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之内存释放","slug":"js之内存释放","date":"2017-03-10T00:28:10.000Z","updated":"2017-03-10T11:09:42.526Z","comments":true,"path":"2017/03/10/js之内存释放/","link":"","permalink":"http://jmu.name/2017/03/10/js之内存释放/","excerpt":"","text":"具体可查看高程三关于各类浏览器对内存的管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt;有本事点我啊~~&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //堆内存 //对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存,堆内存有一个引用的地址,如果外面有变量等知道了这个地址,我们就说这个内存被占用了,就不能销毁了 // var obj1 = &#123;name: \"张三\"&#125;; // var obj2 = obj1; // //我们想要让堆内存释放/销毁,只需要把所有引用它的变量值赋值为null即可，如果当前的堆内存没有任何东西被占用了,那么浏览器会在空闲的时候把它销毁... // obj1 = null; // obj2 = null; //栈内存 //1)全局作用域 //只有当页面关闭的时候全局作用域才会销毁 //2)私有的作用域(只有函数执行会产生私有的作用域) //一般情况下,函数执行会形成一个新的私有的作用域,当私有作用域中的代码执行完成后,我们当前作用域都会主动的进行释放和销毁 //但是还是存在特殊的情况的: //当前私有作用域中的部分内存被作用域以外的东西占用了,那么当前的这个作用域就不能销毁了 //a、函数执行返回了一个引用数据类型的值,并且在函数的外面被一个其他的东西给接收了,这种情况下一般形成的私有作用域都不会销毁 // function fn() &#123; // var num = 100; // return function () &#123; // // &#125; // &#125; // var f = fn();//fn执行形成的这个私有的作用域就不能再销毁了 //b、在一个私有的作用域中给DOM元素的事件绑定方法,一般情况下我们的私有作用域都不销毁 // var oDiv = document.getElementById(\"div1\"); // ~function () &#123; // oDiv.onclick = function () &#123; // // &#125; // &#125;();//当前自执行函数形成的这个私有的作用域也不销毁 //c、下述情况属于不立即销毁-&gt;fn返回的函数没有被其他的东西占用,但是还需要执行一次呢,所以暂时不销毁,当返回的值执行完成后,浏览器会在空闲的时候把它销毁了 -&gt;\"不立即销毁\" // function fn() &#123; // var num = 100; // return function () &#123; // // &#125; // &#125; // fn()();//首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图解1","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之作用域","slug":"js之作用域","date":"2017-03-10T00:26:22.000Z","updated":"2017-03-10T10:57:33.555Z","comments":true,"path":"2017/03/10/js之作用域/","link":"","permalink":"http://jmu.name/2017/03/10/js之作用域/","excerpt":"","text":"如何查找上级作用域12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //如何查找当前作用域的上一级作用域? //看当前函数是在哪个作用域下定义的,那么它的上级作用域就是谁-&gt;和函数在哪执行的没有任何的关系 var num = 12; function fn() &#123; var num = 120; return function () &#123; console.log(num); &#125;; &#125; var f = fn(); f();//-&gt;120 上级作用域是A ~function () &#123; var num = 1200; f();//-&gt;120 上级作用域是A &#125;();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图解1","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之预解释(二)","slug":"js之预解释-二","date":"2017-03-10T00:23:50.000Z","updated":"2017-03-10T10:57:12.680Z","comments":true,"path":"2017/03/10/js之预解释-二/","link":"","permalink":"http://jmu.name/2017/03/10/js之预解释-二/","excerpt":"","text":"预解释中的变态机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //预解释是毫无节操的一种机制 //自从学了预解释,从此节操是路人 //in:\"num\" in window 判断num是否为window这个对象的一个属性,是的话返回true,不是的话返回false // var obj = &#123;name: \"张文静\", age: 17&#125;; // console.log(\"name\" in obj);//-&gt;true // console.log(\"eat\" in obj);//-&gt;false //1、预解释的时候不管你的条件是否成立,都要把带var的进行提前的声明 //window的预解释:var num; -&gt; window.num; // if (!(\"num\" in window)) &#123;//\"num\" in window -&gt;true // var num = 12; // &#125; // console.log(num);//-&gt;undefined //2、预解释的时候只预解释\"=\"左边的,右边的是值,不参与预解释 //匿名函数之函数表达式:把函数定义的部分当做一个值赋值给我们的变量/元素的某一个事件 //window下的预解释:var fn; // fn();//-&gt; undefined() Uncaught TypeError: fn is not a function // var fn = function () &#123; // console.log(\"ok\"); // &#125;; // fn(); -&gt;\"ok\" // function fn()&#123; // console.log(\"ok\"); // &#125; // fn(); -&gt;\"ok\" //3、执行函数定义的那个function在全局作用域下不进行预解释,当代码执行到这个位置的时候定义和执行一起完成了 //自执行函数：定义和执行一起完成了 // (function(num)&#123;&#125;)(100); // ~function(num)&#123;&#125;(100); // +function(num)&#123;&#125;(100); // -function(num)&#123;&#125;(100); // !function(num)&#123;&#125;(100); //4、函数体中return下面的代码虽然不在执行了,但是需要进行预解释;return后面跟着的都是我们返回的值,所以不进行预解释; // function fn() &#123; // //预解释:var num; // console.log(num);//-&gt;undefined // return function () &#123; // // &#125;; // var num = 100; // &#125; // fn(); //5、在预解释的时候,如果名字已经声明过了,不需要从新的声明,但是需要重新的赋值; //在JS中如果变量的名字和函数的名字重复了,也算冲突 //预解释:var fn; window.fn; fn=xxxfff000 window.fn=xxxfff000 // var fn = 13; // function fn() &#123; // console.log(\"ok\"); // &#125; //window预解释: //声明+定义 fn=xxxfff111 //声明 var fn; (不需要重新声明) //声明(不重复进行)+定义 fn=xxxfff222 //-&gt;fn=xxxfff222 fn();//-&gt;2 function fn()&#123;console.log(1);&#125;; fn();//-&gt;2 var fn=10;//-&gt;fn=10 // fn();//-&gt;10() Error:fn is not a function function fn()&#123;console.log(2);&#125;; fn();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之预解释(一)","slug":"js第一天","date":"2017-03-09T12:06:05.000Z","updated":"2017-03-10T10:57:24.602Z","comments":true,"path":"2017/03/09/js第一天/","link":"","permalink":"http://jmu.name/2017/03/09/js第一天/","excerpt":"","text":"预解释1.为何学习预解释？–理解即可 1.避免很多不规范的写法； 2.带var和不带var是有区别的； 3.代码写在里面和外面是有区别的；2.什么是预解释？ 在当前作用域下，在JS代码执行之前，浏览器会对带var和带function的，进行提前声明或定义；3.关于预解释：带var和带function不同：1）带var：只声明不定义；var a;告诉浏览器有个变量叫a，关于a的内容并不知道；2）带function:声明+定义； var fn=xxff00;4.函数执行四阶段：1）形成一个私有作用域2）形参赋值3）预解释：4）代码从上到下的执行；5.作用于链：当函数被调用的时候，会形成一个私有作用域，我们看该私有作用域下，是否有私有变量A：1）如果有私有变量A：那么该作用域中的A，都是私有变量，跟外界没有任何关系2）如果没有私有变量A：到上级作用域进行查找，如果没有，继续往上找，找到window全局作用域还没有的话，报错；6.带var和不带var的区别：1）带var:1)在全局环境下，属于window的全局属性 2）带var会进行预解释2）不带var：1)属于window的全局属性 2)不带var不会进行预解释；7.私有变量有2种：1）当前作用域下，带var的;2）形参；8.栈内存和堆内存：栈内存：提供了一个供JS代码执行的环境；（里面可以放轻量级的数据：基本数据类型） 全局作用域 和 私有作用域；堆内存：堆内存用来存放引用数据类型； 对象数据类型：键值对 函数数据类型：代码字符串9.预解释无节操：1）只对等号左边带var的，声明但不定义；2) 已经声明过的，不会进行重复声明，但会重新赋值3）在预解释阶段，函数的优先级大于变量； ​12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //JS中的数据类型: //基本数据类型 //number、string、boolean、null、undefined //引用数据类型 //object : &#123;&#125;、[]、/^$/、Date //function // var num = 12; // var obj = &#123;name: \"LaoJI\", age: 7&#125;; // function fn() &#123; // console.log(\"勿忘初心方得始终~~\"); // &#125; // console.log(fn);//-&gt;把整个函数的定义部分(函数本身)在控制台输出 // console.log(fn());//-&gt;把当前函数执行的返回结果(return后面写的是啥,返回值就是啥,如果没有return,默认返回值是undefined) //1、当浏览器加载HTML页面的时候,首先会提供一个供全局JS代码执行的环境-&gt;全局作用域(global/window) //2、预解释(变量提声) //在当前的作用域中,JS代码执行之前,浏览器首先会默认的把所有带var和function的进行提前的声明或者定义 //1)理解声明和定义 //var num=12; //声明(declare):var num; -&gt;告诉浏览器在全局作用域中有一个num的变量了 -&gt;如果一个变量只是声明了但是没有赋值,默认的值是undefined //定义(defined):num=12; -&gt;给我们的变量进行赋值 //2)对于带var和function关键字的在预解释的时候操作还是不一样的 //var -&gt; 在预解释的时候只是提前的声明 //function -&gt;在预解释的时候提前的声明+定义都完成了 //3)预解释只发生在当前的作用域下,例如:开始只对window下的进行预解释,只有函数执行的时候才会对函数中的进行预解释 console.log(num);//-&gt;undefined var num = 12; console.log(num);//-&gt;12 var obj = &#123;name: \"LaoJI\", age: 7&#125;; fn(100,200);//-&gt;可以在上面执行,因为预解释的时候声明+定义就已经完成了 function fn(num1, num2) &#123; var total = num1 + num2; console.log(total); &#125; //3、JS中内存的分类 //栈内存:用来提供一个供JS代码执行的环境 -&gt;作用域(全局作用域/私有的作用域) //堆内存:用来存储引用数据类型的值 -&gt;对象存储的是属性名和属性值,函数存储的是代码字符串...&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 图解1 图解2 关于私有作用域的预解释12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //1、如何区分私有变量和全局变量? //1)在全局作用域下声明(预解释的时候)的变量是全局变量; //2)在\"私有作用域中声明的变量\"和\"函数的形参\"都是私有的变量; //在私有作用域中,我们代码执行的时候遇到了一个变量,首先我们需要确定它是否为私有的变量,如果是私有的变量,那么和外面的没有任何的关系；如果不是私有的,则往当前作用域的上级作用域进行查找,如果上级作用域也没有则继续查找,一直找到window为止...(作用域链) //2、当函数执行的时候(直接目的:让函数体中的代码执行),首先会形成一个新的私有的作用域,然后按照如下的步骤执行: //1)如果有形参,先给形参赋值 //2)进行私有作用域中的预解释 //3)私有作用域中的代码从上到下执行 //... //函数形成一个新的私有的作用域保护了里面的私有变量不受外界的干扰(外面修改不了私有的,私有的也修改不了外面的)--&gt;\"闭包\" // console.log(total);//-&gt;undefined // var total = 0; // function fn(num1, num2) &#123; // console.log(total);//-&gt;undefined // var total = num1 + num2; // console.log(total);//-&gt;300 // &#125; // fn(100, 200); // console.log(total);//-&gt;0 console.log(total);//-&gt;undefined var total = 0; function fn(num1, num2) &#123; console.log(total);//-&gt;total不是私有的,找全局下的total,也就是在这里出现的所有的total其实应该都是全局的 -&gt;0 total = num1 + num2;//-&gt;全局的total=300 console.log(total);//-&gt;300 &#125; fn(100, 200); console.log(total);//-&gt;300&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图解3 全局作用域下var带和不带的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //在全局作用域中,带var和不带var的关系? //区别:带var的可以进行预解释,所以在赋值的前面执行不会报错；不带var的是不能进行预解释的,在前面执行会报错； // console.log(num);//-&gt;undefined // var num = 12; // // console.log(num2);//-&gt;Uncaught ReferenceError: num2 is not defined // num2 = 12; //关系:num2=12 -&gt; 相当于给window增加了一个叫做num2的属性名,属性值是12 //var num = 12; -&gt;首先它相当于给全局作用域增加了一个全局变量num,但是不仅如此,它也相当于给window增加了一个属性名num,属性值是12 // var num = 12; // console.log(num);//-&gt;12 // // num2 = 12; // console.log(num2);//-&gt;12 window.num2 // var total = 0; // function fn() &#123; // console.log(total);//-&gt;0 // total = 100; // &#125; // fn(); // console.log(total);//-&gt;100 //私有作用域中出现的一个变量不是私有的,则往上级作用域进行查找,上级没有则继续向上查找,一直找到window为止,如果window下也没有呢? //我们是获取值:console.log(total); -&gt;报错了 //我们是设置值:total = 100; -&gt;相当于给window增加了一个属性名total,属性值是100 function fn() &#123; //console.log(total);//-&gt;Uncaught ReferenceError: total is not defined total = 100; &#125; fn(); console.log(total);//-&gt;100 //JS中如果在不进行任何特殊处理的情况下,上面的代码报错,下面的代码都不在执行了&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","raw":null,"content":null,"categories":[],"tags":[]}]}