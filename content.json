{"meta":{"title":"前端旅途","subtitle":"在读大学生一枚","description":"希望自己成为那个想成为的人吧","author":"LaoJI","url":"http://jmu.name"},"posts":[{"title":"http协议","slug":"http协议","date":"2018-06-14T02:49:01.000Z","updated":"2018-06-14T12:30:53.555Z","comments":true,"path":"2018/06/14/http协议/","link":"","permalink":"http://jmu.name/2018/06/14/http协议/","excerpt":"","text":"1. http简介http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议 2. url详解百度搜索的一个url地址：https://www.baidu.com/s?name=value 1.http/https: 协议类型 2.host：主机地址或域名 –192.168.x.xx:8080 地址+端口号 –www.xxx.com 域名 –localhost8080 localhost是本机地址 3.port:端口号 （默认端口是80可以省略） 4.path: 请求的路径（host之后，问号？之前） 5.? : 问号是分割符号 6.参数： name=value 7.&amp; ： 多个参数用&amp;隔开 3. Get和Post（采用fiddler软件分析）Get没有请求bodyPost有请求body（当然请求body也可以为空）4. 其他请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。","raw":null,"content":null,"categories":[{"name":"协议","slug":"协议","permalink":"http://jmu.name/categories/协议/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://jmu.name/tags/Http/"},{"name":"面试","slug":"面试","permalink":"http://jmu.name/tags/面试/"}]},{"title":"python编码","slug":"python编码","date":"2017-05-29T01:09:44.000Z","updated":"2018-06-15T03:38:32.426Z","comments":true,"path":"2017/05/29/python编码/","link":"","permalink":"http://jmu.name/2017/05/29/python编码/","excerpt":"","text":"字符编码 说起python编码，真是句句心酸。算起来，反复折腾两个来月了。万幸的是，终于梳理清楚了。作为一个共产主义者，一定要分享给大家。如果你还在因为编码而头痛，那么赶紧跟着我咱们一起来揭开py编码的真相吧！ 一. 什么是字符编码？计算机要想工作必须通电,即用‘电’驱使计算机干活,也就是说‘电’的特性决定了计算机的特性。电的特性即高低电平(人类从逻辑上将二进制数1对应高电平,二进制数0对应低电平)，关于磁盘的磁特性也是同样的道理。结论：计算机只认识数字 很明显，我们平时在使用计算机时，用的都是人类能读懂的字符（用高级语言编程的结果也无非是在文件内写了一堆字符），如何能让计算机读懂人类的字符？ 必须经过一个过程： 字符——–（翻译过程）——-&gt;数字 这个过程实际就是一个字符如何对应一个特定数字的标准，这个标准称之为字符编码。 二. 字符编码的发展史 ASCII 记住一句话：计算机中的所有数据，不论是文字、图片、视频、还是音频文件，本质上最终都是按照类似 01010101 二进制存储的，再说简单点，计算机只懂二进制数字！ 所以，目的明确了：如何将我们能识别的符号唯一的与一组二进制数字对应上？于是美利坚的同志想到通过一个电平的高低状态来代指0或1， 八个电平做为一组就可以表示出256种不同状态，每种状态就唯一对应一个字符，比如A—&gt;00010001,而英文只有26个字符，算上一些 特殊字符和数字，128个状态也够用了；每个电平称为一个比特为，约定8个比特位构成一个字节，这样计算机就可以用127个不同字节来存储英语的文字了。这就是ASCII编码。 扩展ANSI编码 刚才说了最开始，一个字节有八位，但是最高位没用上，默认为0；后来为了计算机也可以表示拉丁文，就将最后一位也用上了，从128到255的字符集对应拉丁文啦。至此，一个字节就用满了！ GB2312 计算机漂洋过海来到中国后，问题来了，计算机不认识中文，当然也没法显示中文；而且一个字节所有状态都被占满了，万恶的帝国主义亡我之心不死啊！我党也是棒，自力更生，自己重写一张表，直接生猛地将扩展的第八位对应拉丁文全部删掉，规定一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了；这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。 GBK 和 GB13030 但是汉字太多了，GB2312也不够用，于是规定：只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了GB2312的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 UNICODE编码 很多其它国家都搞出自己的编码标准，彼此间却相互不支持。这就带来了很多问题。于是，国际标谁化组织为了统一编码：提出了标准编码准 即：UNICODE，UNICODE是用两个字节来表示为一个字符，它总共可以组合出65535不同的字符，这足以覆盖世界上所有符号（包括甲骨文） UTF-8 都一统天下了，为什么还要有一个utf8的编码呢？ 大家想，对于英文世界的人们来讲，一个字节完全够了，比如要存储A,本来00010001就可以了，现在吃上了unicode的大锅饭， 得用两个字节：00000000 00010001才行，浪费太严重！ 基于此，美利坚的科学家们提出了天才的想法：utf8。 UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，所以是兼容ASCII编码的。 这样显著的好处是，虽然在我们内存中的数据都是unicode，但当数据要保存到磁盘或者用于网络传输时，直接使用unicode就远不如utf8省空间啦！ 这也是为什么utf8是我们的推荐编码方式。 unicode与utf8的关系： 一言以蔽之：Unicode是内存编码表示方案（是规范），而UTF是如何保存和传输Unicode的方案（是实现）这也是UTF与Unicode的区别。 三. python2的string编码在python2中，有两种字符串类型：str类型和unicode类型；注意，这仅仅是两个名字，python定义的两个名字，关键是这两种数据类型在程序运行时存在内存地址的是什么？ 我们来看一下： 12345678910#coding:utf8s1='苑'print type(s1) # &lt;type 'str'&gt;print repr(s1) #'\\xe8\\x8b\\x91s2=u'苑'print type(s2) # &lt;type 'unicode'&gt;print repr(s2) # u'\\u82d1' 内置函数repr可以帮我们在这里显示存储内容。原来，str和unicode分别存的是字节数据和unicode数据；那么两种数据之间是什么关系呢？如何转换呢?这里就涉及到编码(encode)和解码(decode)了 12345678910111213141516s1=u'苑'print repr(s1) #u'\\u82d1'b=s1.encode('utf8')print bprint type(b) #&lt;type 'str'&gt;print repr(b) #'\\xe8\\x8b\\x91's2='苑昊'u=s2.decode('utf8')print u # 苑昊print type(u) # &lt;type 'unicode'&gt;print repr(u) # u'\\u82d1\\u660a' 无论是utf8还是gbk都只是一种编码规则，一种把unicode数据编码成字节数据的规则，所以utf8编码的字节一定要用utf8的规则解码，否则就会出现乱码或者报错的情况。 四. python3的string编码python3也有两种数据类型：str和bytes；str类型存unicode数据，bytse类型存bytes数据，与python2比只是换了一下名字而已。 123456789101112131415import jsons='苑昊'print(type(s)) #&lt;class 'str'&gt;print(json.dumps(s)) # \"\\u82d1\\u660a\"b=s.encode('utf8')print(type(b)) # &lt;class 'bytes'&gt;print(b) # b'\\xe8\\x8b\\x91\\xe6\\x98\\x8a'u=b.decode('utf8')print(type(u)) #&lt;class 'str'&gt;print(u) #苑昊print(json.dumps(u)) #\"\\u82d1\\u660a\" 五. 文件从磁盘到内存的编码说到这，才来到我们的重点！ 抛开执行执行程序，请问大家，文本编辑器大家都是用过吧，如果不懂是什么，那么word总用过吧，ok，当我们在word上编辑文字的时候，不管是中文还是英文，计算机都是不认识的，那么在保存之前数据是通过什么形式存在内存的呢？yes，就是unicode数据，为什么要存unicode数据，这是因为它的名字最屌：万国码！解释起来就是无论英文，中文，日文，拉丁文，世界上的任何字符它都有唯一编码对应，所以兼容性是最好的。 好，那当我们保存了存到磁盘上的数据又是什么呢？ 答案是通过某种编码方式编码的bytes字节串。比如utf8-－－一种可变长编码，很好的节省了空间；当然还有历史产物的gbk编码等等。于是，在我们的文本编辑器软件都有默认的保存文件的编码方式，比如utf8，比如gbk。当我们点击保存的时候，这些编辑软件已经”默默地”帮我们做了编码工作。 那当我们再打开这个文件时，软件又默默地给我们做了解码的工作，将数据再解码成unicode,然后就可以呈现明文给用户了！所以，unicode是离用户更近的数据，bytes是离计算机更近的数据。 说了这么多，和我们程序执行有什么关系呢？ 先明确一个概念：py解释器本身就是一个软件，一个类似于文本编辑器一样的软件！ 现在让我们一起还原一个py文件从创建到执行的编码过程： 打开pycharm，创建hello.py文件，写入 123ret=1+1s='苑昊'print(s) 当我们保存的的时候，hello.py文件就以pycharm默认的编码方式保存到了磁盘；关闭文件后再打开，pycharm就再以默认的编码方式对该文件打开后读到的内容进行解码，转成unicode到内存我们就看到了我们的明文； 而如果我们点击运行按钮或者在命令行运行该文件时，py解释器这个软件就会被调用，打开文件，然后解码存在磁盘上的bytes数据成unicode数据，这个过程和编辑器是一样的，不同的是解释器会再将这些unicode数据翻译成C代码再转成二进制的数据流，最后通过控制操作系统调用cpu来执行这些二进制数据，整个过程才算结束。 那么问题来了，我们的文本编辑器有自己默认的编码解码方式，我们的解释器有吗？ 当然有啦，py2默认ASCII码，py3默认的utf8，可以通过如下方式查询 12import sysprint(sys.getdefaultencoding()) 大家还记得这个声明吗？ coding:utf8 是的，这就是因为如果py2解释器去执行一个utf8编码的文件，就会以默认地ASCII去解码utf8，一旦程序中有中文，自然就解码错误了，所以我们在文件开头位置声明coding:utf8，其实就是告诉解释器，你不要以默认的编码方式去解码这个文件，而是以utf8来解码。而py3的解释器因为默认utf8编码，所以就方便很多了。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-03-27T03:10:17.436Z","updated":"2017-03-09T12:16:16.000Z","comments":true,"path":"2017/03/27/hello-world/","link":"","permalink":"http://jmu.name/2017/03/27/hello-world/","excerpt":"","text":"从头开始。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"CSS3day2","slug":"CSS3day2","date":"2017-03-16T10:25:16.000Z","updated":"2017-03-16T10:38:22.304Z","comments":true,"path":"2017/03/16/CSS3day2/","link":"","permalink":"http://jmu.name/2017/03/16/CSS3day2/","excerpt":"","text":"1、边框边框圆角： border-radius:30px; border-radius:30px 40px 50px 60px; 赋值规律： 从左上开始，顺时针赋值，如果这个角没有值 ，去对角； border-radius: 40px/60px; 边框阴影： box-shadow: 水平位移 垂直位移 模糊程度 阴影大小 阴影颜色 外/内阴影(inset) 边框图片： border-image-source: 图片路径 border-image-slice: 裁剪 border-image-width: 边框宽度 border-image-repeat: 边框图片的平铺 repeat: 图片显示不完整 round: 图片平铺 优化了，图片会完整显示 stretch: 拉伸 2、背景： 背景可以改变大小，可以有多个背景 background-size: 30px 30px; background-size: 30% 30%; background-size: cover; 覆盖 background-size: contain; 包含 可以有多个背景: 多个背景按照正常的语法格式书写，每个背景使用逗号隔开 背景原点： background-origin: content-box padding-box border-box 背景裁剪 background-clip: content-box padding-box border-box 3、渐变 线性渐变： background-image: linear-gradient(方向，起始颜色，终止颜色); 方向：to left right bottom top 35deg 径向渐变： radial-gradient（辐射半径 中心点位置，起始颜色，终 止颜色） 中心点颜色，at left，right，top，bottom，center at 50px（水平距离） 50px（垂直距离） 4、过渡 /* 过渡属性* /*transition:width 2s,background-color 2s;*/ /* 如果多个过度的 特性是一样的 可以简写*/ /* transition: 过渡属性 持续时间 运动曲线 延迟时间*/ transition:all 4s linear 1s ; /* 过渡必须加给盒子本身*/ /* 过渡的属性详解*/ transition：过渡属性 过渡时间 速度曲线（linear：匀速） 延迟时间 transition-property：过渡属性 transition-duration：过渡持续时间 transition-timimg-function：运动曲线 linear：匀速 ease：减速 ease-in：加速 ease-out：减速 ease-in-out：先加速后减速 transition-delay：过渡延迟 如果需要所有属性都过渡 transition-property：all； 5、2D变换 transform 缩放、旋转、移动 变换后不会影响其他盒子 缩放scale（倍率） 不可以写百分数 大于1是放大，小于一缩小 写一个值，宽高等比缩放 内容也会等比缩放 写两个值，第一个是水平缩放倍率，第二个是垂直缩放倍率 位移translate（） 右移正数，左移负数（右下为正，左下为负） 第一个值水平移动，第二个值垂直移动距离 可写百分比数值，相对与自身的尺寸 盒子在父盒子中居中方法 position：absolute； left：50%； transform：translate（-50%）； 旋转：rotate（角度） 正值顺时针，负值逆时针 旋转中心：transform-origin：水平坐标 垂直坐标 默认旋转中心：几何中心 学习案列","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之基础(一）","slug":"js之基础-一）","date":"2017-03-13T11:37:47.000Z","updated":"2017-03-13T11:52:47.663Z","comments":true,"path":"2017/03/13/js之基础-一）/","link":"","permalink":"http://jmu.name/2017/03/13/js之基础-一）/","excerpt":"","text":"先复习点基础的css和html知识。1、如何的给我们的HTML结构增加CSS样式 1)行内样式 -&gt;直接的在HTML标签上增加style=’….样式都写在这里 src12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 应用于单独的给某一个元素增加样式(一般在写css样式的时候我们都 不用) 2)**内嵌样式** -&gt;在HEAD中增加style标签,然后把需要给元素设置的样式都写在style里面 3)**外联样式** -&gt;为了让HTML页面中的标签和我们的样式分离开，我们把样式写在一个外部的文件中，然后在通过link引入进来 `&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/test1.css&quot;/&gt;` 4)**导入式** -&gt;和外链式相同，都是把样式文件写在外面，然后通过@import导入进来 `@import &quot;css/test2.css&quot;;`# JS中常用的几种输出方式 ### 1、alert(&quot;我们要输出的内容&quot;) ## -&gt;在浏览器中弹出一个对话框,然后把要输出的内容展示出来 -&gt;alert都是把要输出的内容首先转换为字符串然后在输出的 ## 2、document.write(&quot;我们要输出的内容&quot;) ## -&gt;直接的在页面中展示我们输出的内容 ## 3、console.log(我们要输出的内容) ## -&gt;在控制台输出我们的内容 -&gt;如何打开/查看控制台 -&gt;所有的浏览器都是F12这个键打开，拿谷歌浏览器来说，控制台包含了很多项： Elements:展示的是我们页面中的HTML结构,但是它最主要的功能就是 随时的调试我们的css样式(等价于火狐浏览器中的fire bug) Console:我们在控制台输出的内容都可以在这里查看,不仅如此,我该 可以在这里编写js代码 Sources:我们网站中的CSS/JS/HTML所有页面的文件都在这里可以下 载查看,可以通过这个扒别人的源码 Network:展示了页面所有的加载资源(CSS/JS/img/Ajax/ JSONP...)，并且每一个资源文件加载的时间都能看到, 通过这个我们可以进行页面的性能优化 ...... -&gt;console.dir(我们要输出的内容) 这种方式比.log输出的内容更加的详细 -&gt;console.table&gt; [这里对console.table讲的很清楚](http://www.cnblogs.com/justany/p/3429097.html &quot;去看看吧&quot;)## 4、value ## -&gt;给文本框(表单元素)赋值内容 -&gt;获取文本框中(表单元素)的内容 document.getElementById(&quot;search&quot;).value = &quot;我们要给#search这个文本框添加的内容&quot;;## 5、innerHTML/innerText ## -&gt;给除了表单元素的标签赋值内容 document.getElementById(&quot;div1&quot;).innerHTML = &quot;勿忘初心方 得始终~~&quot;; document.getElementById(&quot;div1&quot;).innerText = &quot;在没有努力 之前不要谈天赋和基础~~&quot;;### innerHTML和innerText的区别 ## 1)innerHTML在赋值的时候,如果遇到了有效的HTML标签会把它当做真 正的标签处理,标签就可以起到自己的作用了；innerText不管是不是 标签都当做文本来赋值，那么看到的都是文本，标签起不到自己的作 用；(总结：在赋值的时候innerHTML可以识别HTML标签，而 innerText不能识别) document.getElementById(&quot;div1&quot;).innerHTML = &quot;&lt;a href=&apos;http://www.zhufengpeixun.cn/&apos;&gt;珠峰培训的官网&lt;/a&gt;&quot;; document.getElementById(&quot;div1&quot;).innerText = &quot;&lt;a href=&apos;http://www.zhufengpeixun.cn/&apos;&gt;珠峰培训的官网&lt;/a&gt;&quot;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 2)在部分火狐浏览器中，不支持innerText,而innerHTML是所有浏览 器都支持的 思考题：script上除了type属性还有哪些常用的属性? defer asyncJS:JavaScript的一个缩写,它是一门轻量级的脚本&quot;编程语言&quot;,它是由三部分组成的: ECMAScript:定义了JS的基本语法、命名规范、变量、数据类型、操作语句...最为基础也是最为核心的知识DOM: document object model 文档对象模型 -&gt;提供了JS操作页面中元素的常用方法和属性(例如:getElementById就是DOM提供的一个获取元素的方法)BOM: browser object model 浏览器对象模型 -&gt;提供了JS操作浏览器的一些相关的属性和方法(例如:我们可以监听浏览器的关闭事件,在关闭的时候做一些自己的事情)```javascript var num = 12; var str = &quot;LaoJI&quot;; var boo = true;//false var n = null; var u = undefined; var obj = &#123;name: &quot;LaoJI&quot;, age: 25&#125;;//对象 var ary = [12, 23, 34, 45];//数组 var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/;//正则 var fn = function () &#123; &#125;; 1、JS中的数据类型一共分为两大类 [基本数据类型/值类型] number、string、boolean、null、undefined [引用数据类型] object对象数据类型[&#123;&#125;对象、[]数组、/^$/正则...] function函数数据类型 2、用JS检测它到底是说什么数据类型的 1)typeof 用来检测数据类型的逻辑运算符 typeof value; -&gt;检测value这个值的数据类型 console.log(typeof 12);//-&gt;&quot;number&quot; 在控制台看到的是没有加&quot;&quot;，这是浏览器的一个机制,在JS中输出,在控制台默认的把&quot;&quot;给省略了 返回值:首先是一个字符串,其次里面才包含了我们对应的数据类型,例如:&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot;、&quot;undefined&quot;... 注意: console.log(typeof null);//-&gt;&quot;object&quot; typeof不能具体的细分object下的数组、正则、对象，因为不管检测哪一个返回的都是&quot;object&quot;,例如：typeof [12] -&gt;&quot;object&quot; typeof /^$/ -&gt;&quot;object&quot; BAT面试题 console.log(typeof typeof typeof typeof [12, 23, 34]);//-&gt;&quot;string&quot; typeof检测的返回值不管是啥，首先都是一个字符串，如果出现两个及以上同时检测的话，最后结果一秒钟出答案-&gt;&quot;string&quot; typeof [12, 23, 34] -&gt; &quot;object&quot; typeof &quot;object&quot; -&gt; &quot;string&quot; typeof &quot;string&quot; -&gt; &quot;string&quot; typeof &quot;string&quot; -&gt; &quot;string&quot; 2)instanceof 判断某一个实例是否属于这个类 3)constructor 通过实例的构造函数的执行检测数据类型 4)Object.prototype.toString.call() 调用Object基类原型上的toString方法，让里面的this变为我们要检测值，由此返回对应的数据类型 自然界中的有效数字：正数、负数、零、小数 1、JS中也有一个非常变态的也是数字:NaN NaN:not a number 不是一个数 1)但是它是number类型的 typeof NaN -&gt;&quot;number&quot; 2)由于NaN包含的内容太广泛了,所以NaN和NaN是不相等的 NaN==NaN -&gt;false 2、将其他数据类型的值转化为number类型 1)Number(value) 严格强制的把value转化为number类型值 Number(&quot;100&quot;) -&gt; 100 Number(&quot;100px&quot;) -&gt; NaN 严格:对于一个字符串来说,只有所有的字符都是有效的数字才能转化为数字，只要有一个字符不是，结果就是NaN Number(&quot;&quot;) -&gt; 0 2)parseInt/parseFloat 非严格转换，把其他数据值转换为数字类型的 parseInt(&quot;100px&quot;) -&gt; 100 从左到右查找有效的数字字符,然后把找到的转换为数字，一但遇到一个非有效数字的字符，则停止查找(不管后面是否还有数字都不在找了) parseInt(&quot;100px200&quot;) -&gt; 100 parseInt(&quot;px100&quot;) -&gt; NaN 如果一个都没有找到的话，结果就是NaN parseInt(&quot;100.5px&quot;) -&gt; 100 parseFloat(&quot;100.5px&quot;) -&gt; 100.5 parseFloat比parseInt多识别一个小数点 3、我可以通过判断 &quot;wee&quot;==NaN 如果相等,就说明&quot;wee&quot;不是一个有效数字吗? -&gt;不能，因为NaN和自己都不相等，它和任何一个值都不是相等的 在JS中提供了一个检测是否为有效数字的方法-&gt;isNaN(value) 检测value是否为一个有效的数字，如果是有效的数字返回false，如果不是有效数字才返回true isNaN(12) -&gt;false 说明12是一个有效的数字 isNaN(&quot;12&quot;) -&gt;false 说明“12”是一个有效的数字，当检测的时候，检测的值不是一个number类型的，我们首先转换为number类型，然后在进行判断 4、保留小数点后面的位数 -&gt; toFixed console.log(3.141592654.toFixed(2));//-&gt;&quot;3.14&quot; =:赋值 右边是值,左边是我们的变量,把值赋值给变量 var num = 12;//把12赋值给变量num num=12 var num2 = num;//把num这个变量存储(代表)的值赋值给变量num2 num2=12 ==:比较 判断左边和右边是否相等,相等的话返回的结果是true,不相等返回的结果是false 12==12 -&gt; true &quot;12&quot;==12 -&gt; true 在==进行比较的时候，首先会判断左右两边的数据类型是否一致，如果数据类型相同则继续比较值；如果左右两边的数据类型不一样，浏览器会默认的把它们转换成一样的数据类型才比较；例如： &quot;12&quot;==12 左边是个字符串，右边是一个数字，浏览器首先会把左边的字符串转换为数字12,然后在和右边比较 浏览器是如和的把字符串转化为数字的? -&gt; Number(&quot;12&quot;) 除了字符串和数字以外，其他的数据类型在进行比较的时候，是如何的转换的呢? -&gt;免费课教材最后一页 7.2附表 ===:绝对比较 如果遇到两边的数据类型不一行的话，返回的结果就是不相等，不会像==一样进行数据类型的转换 BAT实战面试题: var num = parseInt(&quot;px100&quot;);//-&gt;num=NaN if (num == 100) { console.log(100); } else if (num == NaN) { console.log(NaN); } else if (typeof num === &quot;number&quot;) {//typeof NaN -&gt;&quot;number&quot; console.log(&quot;number&quot;); } else { console.log(&quot;啥也不是&quot;); } //-&gt;&quot;number&quot;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"HTML5(一)","slug":"HTML5-一","date":"2017-03-13T10:53:43.000Z","updated":"2017-03-13T11:32:40.641Z","comments":true,"path":"2017/03/13/HTML5-一/","link":"","permalink":"http://jmu.name/2017/03/13/HTML5-一/","excerpt":"","text":"1、HTML5:HTML4.1 网页开发： 结构: html4.0 样式：css css2 行为：js HTML5: 是HTML4的升级版本(狭义) 结构：html5 样式：css3 行为：js API 有所增强 地理定位 web存储 拖拽 HTML5广义的概念: 代表着浏览器技术发展的一阶段，HTML5+CSS3+js API 一套前端技术的组合； 案列 2、新增语义化标签header 头部 nav 导航 section 区域 aside 侧边栏 article 文章 footer 底部 progress 进度条 案列 3、表单 表单类型： type=”text” email tel url search number step:步长 color range value max min time date month week 有兼容性问题 案列 表单元素： ``` &lt;input type=&quot;search&quot; list=&quot;sex&quot;/&gt; 数据列表 &lt;datalist id=&quot;sex&quot;&gt; &lt;option&gt;男&lt;/option&gt; &lt;option&gt;男&lt;/option&gt; &lt;option&gt;男&lt;/option&gt; &lt;/datalist&gt; &lt;output&gt;&lt;/output&gt; 输出信息 &lt;keygen/&gt; 生成密钥的 用于表单安全传输 &lt;meter&gt;&lt;/meter&gt; 度量器 max min value low high &lt;progress&gt;&lt;/progress&gt; 进度条 max min value 表单属性： placeholder:提示文字 autofocus:自动聚焦 autocomplete：自动完成（填充） on 开启（默认） off 取消提示 required:必填 multiple: 多选 novalidate: 关闭表单的默认验证功能 用于form pattern: 自定义正则验证 pattern=&quot;\\D+&quot;; 表单事件： oninput:当用户输入时 触发 oninvalid:当验证不通过是触发--&gt;设置验证不通过时的提示文字 ` 案列 4、多媒体之前： 在网页上播放 多媒体 必须依赖于第三方 插件 mediaplay: 快播： falsh插件： H5里面提供了 视频 和 音频的标签 audio video 案列 5、DOM拓展document 对象 文档对象 当在浏览器中 打开一个页面后， 浏览器首先会来解析我们的 网页，把解析出来的数据，存放到一个DOM对象中； document.getElmentById(); 在H5中 DOM新增的功能： jquery--- $(&apos;.box&apos;); $(&apos;#box&apos;); $(&apos;div.box); $(&apos;div p&apos;); 案列 获取单个元素：document.querySelector(&apos;.box‘); 获取所有符合条件的元素： 返回的数组 document.querySeletorAll(&apos;.box&apos;); 控制类名的API： node.classList.add();添加类名 node.classList.remove()；删除类名 node.classlist.contains();判断是否包含指定的类名 node.classList.toggle()；切换指定的类名 案列 综合案列tab标签 Tab栏练习","raw":null,"content":null,"categories":[],"tags":[]},{"title":"CSS3之选择器","slug":"CSS3之选择器","date":"2017-03-12T10:10:54.000Z","updated":"2017-03-12T12:37:15.301Z","comments":true,"path":"2017/03/12/CSS3之选择器/","link":"","permalink":"http://jmu.name/2017/03/12/CSS3之选择器/","excerpt":"","text":"CSS3刚接触。我尽量把我学习过程分享给大家。大家有啥问题评论下哈。 div&gt;p: 子代 div+p： div后面相邻的第一个p div~p: div后面所有的兄弟p 案列 1、属性选择器：id选择器 # 通过id 来选择 类名选择器 . 通过类名来选择 属性选择器 [] 通过标签属性来选择器 语法： 标志性符号：[] ^: 开头 $:结尾 *：包含 E[title] : 选中页面的E元素，并且E需要带有title属性 E[title=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值为abc E[title^=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值以abc开头 E[title$=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值以abc结尾 E[title*=&quot;abc&quot;] :选中页面的E元素，并且E需要带有title属性,属性值包含abc 案列 结构伪类选择器： E：first-child 选中父元素中的第一个子元素 E：last-child 选中父元素中的最后一个子元素 E：nth-child(1) 选中父元素中的第5个子元素 n: 0,1,2,3,4。。。 偶数： 2n even 奇数：2n-1 odd 前5个： -n+5 E：nth-last-child(3): 从后向前选择， 选中倒数第3个 div:nth-child(9) 注意：所选到的元素的类型 必须是指定的类型E,否则选择无效； E：empty 表示元素为空的状态 E:target: 表示元素被激活的状态 要配合锚点使用 案列 伪元素：通过css模拟出html效果 E::before E::after 必须有content 属性 案列 伪元素选择器：E::first-letter 选中第一个字母 E::first-line选中第一行 E::selection: 表示选择的区域 通过设置 color background 案列 CSS3中新增了两种颜色模式 ：RGBA: red green blue (0-255) alpha: 透明度 （0-1） HSLA: H:色调 0-360 0 红色 120 绿色 240 蓝色 S:饱和度 0%-100% L:亮度 0%-100% A：alpha 透明度 0-1 text-shadow:水平位移 垂直位移 模糊度 颜色 盒子模型： 三个盒子： content-box padding-box border-box box-sizing: border-box(内减模式)border-box(内减模式) /content-box（外加模式）(默认值) box-sizing: border-box 盒模型 私有化前缀： 浏览器私有化前缀： -webkit-: 谷歌 苹果 -moz-:火狐 -ms-：ie -o-：欧朋","raw":null,"content":null,"categories":[],"tags":[]},{"title":"A pageDemo","slug":"A-pageDemo","date":"2017-03-11T02:19:36.000Z","updated":"2017-03-11T02:22:00.569Z","comments":true,"path":"2017/03/11/A-pageDemo/","link":"","permalink":"http://jmu.name/2017/03/11/A-pageDemo/","excerpt":"","text":"#学完css后做的一个小小的主页demo(浏览者莫喷啦)#下面图解主页面的盒子模型 头部 导航 信息 新闻 底部 源码请左转-&gt; https://github.com/HeyGary/pagedemo/","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hexo站点之域名配置(GitHub)","slug":"Hexo站点之域名配置-GitHub","date":"2017-03-10T13:25:10.000Z","updated":"2017-03-10T13:39:12.089Z","comments":true,"path":"2017/03/10/Hexo站点之域名配置-GitHub/","link":"","permalink":"http://jmu.name/2017/03/10/Hexo站点之域名配置-GitHub/","excerpt":"","text":"起因 因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。 步骤 购买域名 腾讯云、阿里云都是不错的选择。博主选用的是腾讯云的 建议如果只是作为自己的博客使用建议不要购买.com的域名（辣么贵） 域名解析 这里没图我说个** 先登录腾讯云 点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是heygary.github.io 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：jmu.name。实践证明如果此时你填写的是www.jmu.name那么以后你只能用www.jmu.name访问，而如果你填写的是jmu.name。那么用www.jmu.name和jmu.name访问都是可以的。重新清理hexo(hexo clean命令),并发布即可用新的域名访问。 搭建完成访问出现404 可能的原因是：绑定了个人域名，但是域名解析错误。域名解析正确但你的域名是通过国内注册商注册的，你的域名因没有实名制而无法访问。你认为配置没有问题，那么可能只是你的浏览器在捣鬼，可尝试清除浏览器缓存再访问或者换个浏览器访问。也有可能是你的路由器缓存导致的错觉，所以也可以尝试换个局域网访问你的网站。最有可能的原因是你下载的hexo有问题，导致所有的东西都上传到了github,而导致index页面在主域名的下一级目录。你可以尝试查看上传的内容，找到index页面，在域名后面添加下一级目录。若能访问index页面（此时样式可能是乱的），则证明是hexo安装有问题，笔者当时遇到的就是这个问题。可卸载重新安装。注：1，2默认你的CNAME文件配置没有问题，如果没有绑定个人域名，则不需要CNAME文件。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Git操作","slug":"Git操作","date":"2017-03-10T04:21:43.000Z","updated":"2017-03-13T11:25:23.658Z","comments":true,"path":"2017/03/10/Git操作/","link":"","permalink":"http://jmu.name/2017/03/10/Git操作/","excerpt":"","text":"使用中遇到的问题最近更新了Git版本，发现在github上建立了一个仓库，然后关联本地库的时候pull失败，错误为fatal: refusing to merge unrelated histories，查找后找到了解决方案 将之前的git pull origin master修改为一下代码git pull origin master –allow-unrelated-histories 1.常用命令：1)win+R:打开命令行2)git –version:查看git的版本，知道git安装是否成功；3）清除命令行：cls(window系统) clear(linux,mac);4)ls -a:查看当前文件夹下所有的文件（隐藏+显示的文件夹）5）添加远程通道：git remote add XXXX;删除远程通道 git remote rm 通道名 2.git配置：git config –global user.name “你的github用户名”git config –global user.email “你的github邮箱” 3.创建一个git本地仓库：1、新建一个文件夹 2、进入这个文件夹，右键git bash or 左手shift+右键“在此处打开命令窗口” 3、git init :把本地仓库初始化为一个git可以管理的仓库； 4.建立远程仓库：1.右上角“+” 2.输入仓库名称- create 5.把“本地仓库”所有内容，推送到“远程仓库” #：1）git add . git add -A git add --all 2) git commit -m&quot;注释内容&quot; 3) git push origin master 6.学员更新老师讲义（开发人员更新项目）1）登录自己的github，然后把老师讲义地址，复制到地址栏 https://github.com/zhufengpeixun/Javascript201614.git 2）把自己的远程仓库，下载到本地； git clone https://github.com/leilei1238/Javascript201614.git 3)连接老师远程通道： git remote add teacher https://github.com/zhufengpeixun/Javascript201614.git 查看链接了哪些通道：git remote -v 删除远程通道：git remote rm 通道名称 4)更新老师远程通道 git remote update teacher git pull teacher master .......................................","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之内存释放","slug":"js之内存释放","date":"2017-03-10T00:28:10.000Z","updated":"2017-03-10T11:09:42.526Z","comments":true,"path":"2017/03/10/js之内存释放/","link":"","permalink":"http://jmu.name/2017/03/10/js之内存释放/","excerpt":"","text":"具体可查看高程三关于各类浏览器对内存的管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt;有本事点我啊~~&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //堆内存 //对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存,堆内存有一个引用的地址,如果外面有变量等知道了这个地址,我们就说这个内存被占用了,就不能销毁了 // var obj1 = &#123;name: \"张三\"&#125;; // var obj2 = obj1; // //我们想要让堆内存释放/销毁,只需要把所有引用它的变量值赋值为null即可，如果当前的堆内存没有任何东西被占用了,那么浏览器会在空闲的时候把它销毁... // obj1 = null; // obj2 = null; //栈内存 //1)全局作用域 //只有当页面关闭的时候全局作用域才会销毁 //2)私有的作用域(只有函数执行会产生私有的作用域) //一般情况下,函数执行会形成一个新的私有的作用域,当私有作用域中的代码执行完成后,我们当前作用域都会主动的进行释放和销毁 //但是还是存在特殊的情况的: //当前私有作用域中的部分内存被作用域以外的东西占用了,那么当前的这个作用域就不能销毁了 //a、函数执行返回了一个引用数据类型的值,并且在函数的外面被一个其他的东西给接收了,这种情况下一般形成的私有作用域都不会销毁 // function fn() &#123; // var num = 100; // return function () &#123; // // &#125; // &#125; // var f = fn();//fn执行形成的这个私有的作用域就不能再销毁了 //b、在一个私有的作用域中给DOM元素的事件绑定方法,一般情况下我们的私有作用域都不销毁 // var oDiv = document.getElementById(\"div1\"); // ~function () &#123; // oDiv.onclick = function () &#123; // // &#125; // &#125;();//当前自执行函数形成的这个私有的作用域也不销毁 //c、下述情况属于不立即销毁-&gt;fn返回的函数没有被其他的东西占用,但是还需要执行一次呢,所以暂时不销毁,当返回的值执行完成后,浏览器会在空闲的时候把它销毁了 -&gt;\"不立即销毁\" // function fn() &#123; // var num = 100; // return function () &#123; // // &#125; // &#125; // fn()();//首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图解1","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之作用域","slug":"js之作用域","date":"2017-03-10T00:26:22.000Z","updated":"2017-03-10T10:57:33.555Z","comments":true,"path":"2017/03/10/js之作用域/","link":"","permalink":"http://jmu.name/2017/03/10/js之作用域/","excerpt":"","text":"如何查找上级作用域12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //如何查找当前作用域的上一级作用域? //看当前函数是在哪个作用域下定义的,那么它的上级作用域就是谁-&gt;和函数在哪执行的没有任何的关系 var num = 12; function fn() &#123; var num = 120; return function () &#123; console.log(num); &#125;; &#125; var f = fn(); f();//-&gt;120 上级作用域是A ~function () &#123; var num = 1200; f();//-&gt;120 上级作用域是A &#125;();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图解1","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之预解释(二)","slug":"js之预解释-二","date":"2017-03-10T00:23:50.000Z","updated":"2017-03-10T10:57:12.680Z","comments":true,"path":"2017/03/10/js之预解释-二/","link":"","permalink":"http://jmu.name/2017/03/10/js之预解释-二/","excerpt":"","text":"预解释中的变态机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //预解释是毫无节操的一种机制 //自从学了预解释,从此节操是路人 //in:\"num\" in window 判断num是否为window这个对象的一个属性,是的话返回true,不是的话返回false // var obj = &#123;name: \"张文静\", age: 17&#125;; // console.log(\"name\" in obj);//-&gt;true // console.log(\"eat\" in obj);//-&gt;false //1、预解释的时候不管你的条件是否成立,都要把带var的进行提前的声明 //window的预解释:var num; -&gt; window.num; // if (!(\"num\" in window)) &#123;//\"num\" in window -&gt;true // var num = 12; // &#125; // console.log(num);//-&gt;undefined //2、预解释的时候只预解释\"=\"左边的,右边的是值,不参与预解释 //匿名函数之函数表达式:把函数定义的部分当做一个值赋值给我们的变量/元素的某一个事件 //window下的预解释:var fn; // fn();//-&gt; undefined() Uncaught TypeError: fn is not a function // var fn = function () &#123; // console.log(\"ok\"); // &#125;; // fn(); -&gt;\"ok\" // function fn()&#123; // console.log(\"ok\"); // &#125; // fn(); -&gt;\"ok\" //3、执行函数定义的那个function在全局作用域下不进行预解释,当代码执行到这个位置的时候定义和执行一起完成了 //自执行函数：定义和执行一起完成了 // (function(num)&#123;&#125;)(100); // ~function(num)&#123;&#125;(100); // +function(num)&#123;&#125;(100); // -function(num)&#123;&#125;(100); // !function(num)&#123;&#125;(100); //4、函数体中return下面的代码虽然不在执行了,但是需要进行预解释;return后面跟着的都是我们返回的值,所以不进行预解释; // function fn() &#123; // //预解释:var num; // console.log(num);//-&gt;undefined // return function () &#123; // // &#125;; // var num = 100; // &#125; // fn(); //5、在预解释的时候,如果名字已经声明过了,不需要从新的声明,但是需要重新的赋值; //在JS中如果变量的名字和函数的名字重复了,也算冲突 //预解释:var fn; window.fn; fn=xxxfff000 window.fn=xxxfff000 // var fn = 13; // function fn() &#123; // console.log(\"ok\"); // &#125; //window预解释: //声明+定义 fn=xxxfff111 //声明 var fn; (不需要重新声明) //声明(不重复进行)+定义 fn=xxxfff222 //-&gt;fn=xxxfff222 fn();//-&gt;2 function fn()&#123;console.log(1);&#125;; fn();//-&gt;2 var fn=10;//-&gt;fn=10 // fn();//-&gt;10() Error:fn is not a function function fn()&#123;console.log(2);&#125;; fn();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"js之预解释(一)","slug":"js第一天","date":"2017-03-09T12:06:05.000Z","updated":"2017-03-10T10:57:24.602Z","comments":true,"path":"2017/03/09/js第一天/","link":"","permalink":"http://jmu.name/2017/03/09/js第一天/","excerpt":"","text":"预解释1.为何学习预解释？–理解即可 1.避免很多不规范的写法； 2.带var和不带var是有区别的； 3.代码写在里面和外面是有区别的；2.什么是预解释？ 在当前作用域下，在JS代码执行之前，浏览器会对带var和带function的，进行提前声明或定义；3.关于预解释：带var和带function不同：1）带var：只声明不定义；var a;告诉浏览器有个变量叫a，关于a的内容并不知道；2）带function:声明+定义； var fn=xxff00;4.函数执行四阶段：1）形成一个私有作用域2）形参赋值3）预解释：4）代码从上到下的执行；5.作用于链：当函数被调用的时候，会形成一个私有作用域，我们看该私有作用域下，是否有私有变量A：1）如果有私有变量A：那么该作用域中的A，都是私有变量，跟外界没有任何关系2）如果没有私有变量A：到上级作用域进行查找，如果没有，继续往上找，找到window全局作用域还没有的话，报错；6.带var和不带var的区别：1）带var:1)在全局环境下，属于window的全局属性 2）带var会进行预解释2）不带var：1)属于window的全局属性 2)不带var不会进行预解释；7.私有变量有2种：1）当前作用域下，带var的;2）形参；8.栈内存和堆内存：栈内存：提供了一个供JS代码执行的环境；（里面可以放轻量级的数据：基本数据类型） 全局作用域 和 私有作用域；堆内存：堆内存用来存放引用数据类型； 对象数据类型：键值对 函数数据类型：代码字符串9.预解释无节操：1）只对等号左边带var的，声明但不定义；2) 已经声明过的，不会进行重复声明，但会重新赋值3）在预解释阶段，函数的优先级大于变量； ​12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //JS中的数据类型: //基本数据类型 //number、string、boolean、null、undefined //引用数据类型 //object : &#123;&#125;、[]、/^$/、Date //function // var num = 12; // var obj = &#123;name: \"LaoJI\", age: 7&#125;; // function fn() &#123; // console.log(\"勿忘初心方得始终~~\"); // &#125; // console.log(fn);//-&gt;把整个函数的定义部分(函数本身)在控制台输出 // console.log(fn());//-&gt;把当前函数执行的返回结果(return后面写的是啥,返回值就是啥,如果没有return,默认返回值是undefined) //1、当浏览器加载HTML页面的时候,首先会提供一个供全局JS代码执行的环境-&gt;全局作用域(global/window) //2、预解释(变量提声) //在当前的作用域中,JS代码执行之前,浏览器首先会默认的把所有带var和function的进行提前的声明或者定义 //1)理解声明和定义 //var num=12; //声明(declare):var num; -&gt;告诉浏览器在全局作用域中有一个num的变量了 -&gt;如果一个变量只是声明了但是没有赋值,默认的值是undefined //定义(defined):num=12; -&gt;给我们的变量进行赋值 //2)对于带var和function关键字的在预解释的时候操作还是不一样的 //var -&gt; 在预解释的时候只是提前的声明 //function -&gt;在预解释的时候提前的声明+定义都完成了 //3)预解释只发生在当前的作用域下,例如:开始只对window下的进行预解释,只有函数执行的时候才会对函数中的进行预解释 console.log(num);//-&gt;undefined var num = 12; console.log(num);//-&gt;12 var obj = &#123;name: \"LaoJI\", age: 7&#125;; fn(100,200);//-&gt;可以在上面执行,因为预解释的时候声明+定义就已经完成了 function fn(num1, num2) &#123; var total = num1 + num2; console.log(total); &#125; //3、JS中内存的分类 //栈内存:用来提供一个供JS代码执行的环境 -&gt;作用域(全局作用域/私有的作用域) //堆内存:用来存储引用数据类型的值 -&gt;对象存储的是属性名和属性值,函数存储的是代码字符串...&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 图解1 图解2 关于私有作用域的预解释12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //1、如何区分私有变量和全局变量? //1)在全局作用域下声明(预解释的时候)的变量是全局变量; //2)在\"私有作用域中声明的变量\"和\"函数的形参\"都是私有的变量; //在私有作用域中,我们代码执行的时候遇到了一个变量,首先我们需要确定它是否为私有的变量,如果是私有的变量,那么和外面的没有任何的关系；如果不是私有的,则往当前作用域的上级作用域进行查找,如果上级作用域也没有则继续查找,一直找到window为止...(作用域链) //2、当函数执行的时候(直接目的:让函数体中的代码执行),首先会形成一个新的私有的作用域,然后按照如下的步骤执行: //1)如果有形参,先给形参赋值 //2)进行私有作用域中的预解释 //3)私有作用域中的代码从上到下执行 //... //函数形成一个新的私有的作用域保护了里面的私有变量不受外界的干扰(外面修改不了私有的,私有的也修改不了外面的)--&gt;\"闭包\" // console.log(total);//-&gt;undefined // var total = 0; // function fn(num1, num2) &#123; // console.log(total);//-&gt;undefined // var total = num1 + num2; // console.log(total);//-&gt;300 // &#125; // fn(100, 200); // console.log(total);//-&gt;0 console.log(total);//-&gt;undefined var total = 0; function fn(num1, num2) &#123; console.log(total);//-&gt;total不是私有的,找全局下的total,也就是在这里出现的所有的total其实应该都是全局的 -&gt;0 total = num1 + num2;//-&gt;全局的total=300 console.log(total);//-&gt;300 &#125; fn(100, 200); console.log(total);//-&gt;300&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图解3 全局作用域下var带和不带的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; //在全局作用域中,带var和不带var的关系? //区别:带var的可以进行预解释,所以在赋值的前面执行不会报错；不带var的是不能进行预解释的,在前面执行会报错； // console.log(num);//-&gt;undefined // var num = 12; // // console.log(num2);//-&gt;Uncaught ReferenceError: num2 is not defined // num2 = 12; //关系:num2=12 -&gt; 相当于给window增加了一个叫做num2的属性名,属性值是12 //var num = 12; -&gt;首先它相当于给全局作用域增加了一个全局变量num,但是不仅如此,它也相当于给window增加了一个属性名num,属性值是12 // var num = 12; // console.log(num);//-&gt;12 // // num2 = 12; // console.log(num2);//-&gt;12 window.num2 // var total = 0; // function fn() &#123; // console.log(total);//-&gt;0 // total = 100; // &#125; // fn(); // console.log(total);//-&gt;100 //私有作用域中出现的一个变量不是私有的,则往上级作用域进行查找,上级没有则继续向上查找,一直找到window为止,如果window下也没有呢? //我们是获取值:console.log(total); -&gt;报错了 //我们是设置值:total = 100; -&gt;相当于给window增加了一个属性名total,属性值是100 function fn() &#123; //console.log(total);//-&gt;Uncaught ReferenceError: total is not defined total = 100; &#125; fn(); console.log(total);//-&gt;100 //JS中如果在不进行任何特殊处理的情况下,上面的代码报错,下面的代码都不在执行了&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","raw":null,"content":null,"categories":[],"tags":[]}]}